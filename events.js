"use strict";

let Events = module.exports;

let Zmq = require("zeromq");

Events.create = async function create({ url, handler }) {
  // replaces `let zmqSubSocket = zmq.socket("sub");`
  let sock = new Zmq.Subscriber();

  console.info(`ZeroMQ Subscriber connecting to '${url}'`);
  void monitor({ sock, handler });

  sock.connect(url);
  console.info("[connect]");

  sock.subscribe("rawtxlock");
  console.log("[subscribe] rawtxlock");

  sock.subscribe("pubhashchainlock");
  console.log("[subscribe] pubhashchainlock");

  // receive() is in c++ land
  // https://github.com/zeromq/zeromq.js/blob/62f6e252f530ea05c86be15b06a58214eac1b34d/src/socket.cc#L307
  // asyncInterator is generic generated by TypeScript
  // https://github.com/zeromq/zeromq.js/blob/62f6e252f530ea05c86be15b06a58214eac1b34d/src/index.ts#L291C1-L292C1
  //console.log(sock);

  /*
    try {
        for await (let [topic, msg] of sock) {
            console.info(`${topic}:`);
            let hex = msg.toString("hex");
            console.info(hex);
        }
    } catch (e) {
        throw e;
    }
  */

  for (;;) {
    let [topicBuf, msgBuf] = await sock.receive().catch(errorToMessage);
    if (topicBuf.length === 0) {
      // intentionally closed
      break;
    }

    let topic = topicBuf.toString("ascii");
    if (topic === "error") {
      console.warn("[error] socket failed to receive", msgBuf);
      continue;
    }

    console.info(`[topic] ${topic}:`);
    let hex = msgBuf.toString("hex");

    handler(null, topic, hex);
  }

  function errorToMessage(e) {
    if (sock.closed) {
      if (e.code === "EAGAIN") {
        return ["", null];
      }
    }
    return ["error", e];
  }
};

// events
// https://github.com/zeromq/zeromq.js/blob/v6.0.0-beta.17/src/observer.cc#L15
let events = {
  errors: [
    "accept:error",
    "bind:error",
    "close:error",
    "handshake:error:auth",
    "handshake:error:other",
    "handshake:error:protocol",
  ],
  intervals: ["connect:retry"],
  notifiers: [
    "handshake",
    "connect",
    "connect:delay",
    "accept",
    "bind",
    "close",
    "disconnect",
    "end",
  ],
};

async function monitor({ sock, handler }) {
  for (;;) {
    let event;
    try {
      event = await sock.events.receive();
    } catch (e) {
      if (!sock.closed) {
        console.error("[error] monitor failed", e);
      }
      break;
    }

    let isError = events.errors.includes(event.type);
    if (isError) {
      let value = event.error?.errno || 0;
      void handler(event.error, event.type, value);
      continue;
    }

    let hasIntervalValue = events.intervals.includes(event.type);
    if (hasIntervalValue) {
      let value = event.interval;
      void handler(event.error, event.type, value);
      continue;
    }

    let isNotifier = events.notifiers.includes(event.type);
    if (isNotifier) {
      let value = null;
      void handler(event.error, event.type, value);
      continue;
    }

    console.warn(`[WARN] unknown event '${event.type}'`);
  }
}

async function main() {
  let zmqUrl = "tcp://10.11.5.104:28332";
  //let zmqUrl = "tcp://10.11.5.1041:28332";
  //let zmqUrl = "tcp://10.11.5.104:28331";
  void Events.create({ url: zmqUrl, handler: onEvent });

  async function onEvent(err, type, value) {
    if (err) {
      console.error(err.stack || err);
      return;
    }

    let subject = `[monitor] ${type}@${zmqUrl}`;
    if (!value) {
      console.info(`${subject}:`);
      return;
    }

    console.info(`${subject}`);
    console.info(value);
  }
}
if (require.main === module) {
  main().catch(function (err) {
    console.error("Error:");
    console.error(err);
  });
}
